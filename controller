#!/usr/bin/env python3
from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtCore import QTimer, QThread, pyqtSignal
from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkRequest
import numpy as np
import cv2
import time
import sys
import zmq

running = True
throttle_prints = 25
rate_limit = 20.0

# Client (e.g., on your laptop)
context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.connect("tcp://tank:5555")
socket.setsockopt(zmq.RCVTIMEO, 1000)

def send_message(message):
    socket.send_string(message)
    try:
        reply = socket.recv_string()
    except zmq.error.Again:
        print("Timeout")

controls = [Qt.Key.Key_Up, Qt.Key.Key_Down, Qt.Key.Key_Left, Qt.Key.Key_Right, Qt.Key.Key_Space]
keymap = {Qt.Key.Key_Space : 1,
          Qt.Key.Key_Left  : 2,
          Qt.Key.Key_Right : 4,
          Qt.Key.Key_Up    : 8,
          Qt.Key.Key_Down  : 16 }

class VideoThread(QThread):
    update_frame_signal = pyqtSignal(QImage)

    def __init__(self, srt_url):
        super().__init__()
        self.srt_url = srt_url
        # OpenCV can handle SRT streams via FFMPEG if the stream URL is passed correctly
        self.cap = cv2.VideoCapture(srt_url)
        self.running = True

    def run(self):
        while self.running:
            if self.cap.isOpened():
                ret, frame = self.cap.read()
                if ret:
                    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    h, w, ch = frame_rgb.shape
                    bytes_per_line = ch * w
                    qt_image = QImage(frame_rgb.data, w, h, bytes_per_line, QImage.Format_RGB888)
                    self.update_frame_signal.emit(qt_image)
                else:
                    print("Failed to read frame")
            else:
                print("Failed to open camera")
            QThread.msleep(66)  # approximately 15fps

    def stop(self):
        self.running = False
        self.cap.release()
        self.quit()

class CameraControlWindow(QMainWindow):
    def __init__(self, rtsp_url):
        super().__init__()

        self.video_thread = VideoThread(rtsp_url)
        self.video_thread.update_frame_signal.connect(self.display_frame)

        self.init_ui()
        self.video_thread.start()

        # Timer to run the control loop more frequently
        self.control_timer = QTimer()
        self.control_timer.timeout.connect(self.control_update)
        self.control_timer.start(10)  # 100 Hz control loop

        self.target = np.array([0.0, 0.0])
        self.speed = np.array([0.0, 0.0])
        self.acceleration = 50  # Example acceleration value
        self.keystate = 0
        self.lastcommand = None

        # Initialize time
        self.previous_time = time.perf_counter()

    def keyPressEvent(self, event):
        # Remove after debug
        if event.key() == Qt.Key.Key_Q:
            sys.exit(0)

        if event.key() in controls and not event.isAutoRepeat():
            self.handle_inputs('pressed', event.key())

    def keyReleaseEvent(self, event):
        if event.key() in controls and not event.isAutoRepeat():
            self.handle_inputs('released', event.key())

    def handle_inputs(self, action, key):
        if action == "pressed":
            self.keystate |= keymap[key]
        elif action == "released":
            self.keystate &= (0xFF & ~keymap[key])

        # coasting is allowed but any keys pressed sets a new goal
        if self.keystate:
            self.target = np.array([0.0,0.0])
            if self.keystate & keymap[Qt.Key.Key_Up]:
                self.target += np.array([100.0,100.0])
            if self.keystate & keymap[Qt.Key.Key_Down]:
                self.target += np.array([-100.0,-100.0])

            # Motor drive is correct but left/right are swapped
            # at the motor driver - swap them here
            if self.keystate & keymap[Qt.Key.Key_Left]:
                self.target += np.array([50.0,-50.0])
            if self.keystate & keymap[Qt.Key.Key_Right]:
                self.target += np.array([-50.0,50.0])

            # braking is immediate
            if self.keystate & keymap[Qt.Key.Key_Space]:
                self.target = self.speed = np.array([0.0,0.0])

            scale = np.max(np.abs(self.target))
            # handle additive overrange
            if scale > 100:
                self.target = self.target * 100.0 / scale

        else:
            self.target = self.speed

    def control_update(self):
        global throttle_prints
        now = time.perf_counter()
        delta_time = now - self.previous_time
        self.previous_time = now

        # Calculate the desired change in speed
        delta = self.target - self.speed
        # Calculate the change in speed allowed by the rate limit
        allowed_delta = np.clip(delta, -rate_limit * delta_time, rate_limit * delta_time)

        # Update speed by applying the allowed change
        self.speed += allowed_delta

        command = 'drive:' + ','.join(np.round(self.speed).astype(int).astype(str))
        if self.lastcommand != command:
            send_message(command)
        self.lastcommand = command

    def init_ui(self):
        # Get screen resolution
        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()

        self.setWindowTitle("Front Camera")
        self.showFullScreen()  # Set the window to fullscreen

        self.image_label = QLabel(self)
        self.image_label.setGeometry(0, 0, screen_rect.width(), screen_rect.height())
        self.image_label.setAlignment(Qt.AlignCenter)

        central_widget = QWidget()
        layout = QVBoxLayout()
        layout.addWidget(self.image_label)
        central_widget.setLayout(layout)

        self.setCentralWidget(central_widget)

    def display_frame(self, qt_image):
        self.image_label.setPixmap(QPixmap.fromImage(qt_image))

    def closeEvent(self, event):
        self.video_thread.stop()
        event.accept()

if __name__ == "__main__":
    rtsp_url = "srt://tank:8890?streamid=read:front"
    app = QApplication(sys.argv)
    window = CameraControlWindow(rtsp_url)
    window.show()
    sys.exit(app.exec_())
