#!/usr/bin/env python3
from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtCore import QTimer, QThread, pyqtSignal
from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkRequest
import numpy as np
import cv2
import time
import sys
import zmq

running = True
throttle_prints = 25
rate_limit = 20.0

# Client (e.g., on your laptop)
context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.connect("tcp://tank:5555")
socket.setsockopt(zmq.RCVTIMEO, 1000)

def send_message(message):
    socket.send_string(message)
    try:
        reply = socket.recv_string()
    except zmq.error.Again:
        print("Timeout")

controls = [Qt.Key.Key_Up, Qt.Key.Key_Down, Qt.Key.Key_Left, Qt.Key.Key_Right, Qt.Key.Key_Space]
keymap = {Qt.Key.Key_Space : 1,
          Qt.Key.Key_Left  : 2,
          Qt.Key.Key_Right : 4,
          Qt.Key.Key_Up    : 8,
          Qt.Key.Key_Down  : 16 }

class CameraControlWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Set up the network manager for the camera feed
        self.network_manager = QNetworkAccessManager()
        self.network_manager.finished.connect(self.handle_response)

        # Set up the UI
        self.label = QLabel(self)
        self.setCentralWidget(self.label)
        self.setWindowTitle("Remote Camera Feed with Keyboard Control")
        self.setGeometry(100, 100, 800, 600)

    def init_ui(self):
        self.setWindowTitle("RTSP Stream Viewer")
        self.setGeometry(100, 100, 800, 600)

        self.image_label = QLabel(self)
        self.image_label.resize(800, 600)

        central_widget = QWidget()
        layout = QVBoxLayout()
        layout.addWidget(self.image_label)
        central_widget.setLayout(layout)

        self.setCentralWidget(central_widget)

    def closeEvent(self, event):
        self.cap.release()
        event.accept()

class VideoThread(QThread):
    update_frame_signal = pyqtSignal(QImage)

    def __init__(self, rtsp_url):
        super().__init__()
        self.rtsp_url = rtsp_url
        self.cap = cv2.VideoCapture(rtsp_url)
        #self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        self.running = True

    def run(self):
        while self.running:
            ret, frame = self.cap.read()

            # Clear buffer by reading frames until the most recent one
            while self.cap.isOpened():
                ret, frame = self.cap.read()
                if not ret:
                    break
                # Continue reading frames until we reach the latest frame
                self.last_frame = frame

            if ret:
                flipped_frame = cv2.flip(self.last_frame, 1)
                frame_rgb = cv2.cvtColor(flipped_frame, cv2.COLOR_BGR2RGB)
                h, w, ch = frame_rgb.shape
                bytes_per_line = ch * w
                qt_image = QImage(frame_rgb.data, w, h, bytes_per_line, QImage.Format_RGB888)
                self.update_frame_signal.emit(qt_image)
            QThread.msleep(33)  # Delay to match the incoming frame rate

    def stop(self):
        self.running = False
        self.cap.release()
        self.quit()

class CameraControlWindow(QMainWindow):
    def __init__(self, rtsp_url):
        super().__init__()

        self.video_thread = VideoThread(rtsp_url)
        self.video_thread.update_frame_signal.connect(self.display_frame)

        self.init_ui()
        self.video_thread.start()

        # Timer to run the control loop more frequently
        self.control_timer = QTimer()
        self.control_timer.timeout.connect(self.control_update)
        self.control_timer.start(10)  # 100 Hz control loop

        self.target = np.array([0.0, 0.0])
        self.speed = np.array([0.0, 0.0])
        self.acceleration = 50  # Example acceleration value
        self.keystate = 0
        self.lastcommand = None

        # Initialize time
        self.previous_time = time.perf_counter()

    def keyPressEvent(self, event):
        # Remove after debug
        if event.key() == Qt.Key.Key_Q:
            sys.exit(0)

        if event.key() in controls and not event.isAutoRepeat():
            self.handle_inputs('pressed', event.key())

    def keyReleaseEvent(self, event):
        if event.key() in controls and not event.isAutoRepeat():
            self.handle_inputs('released', event.key())

    def handle_inputs(self, action, key):
        if action == "pressed":
            self.keystate |= keymap[key]
        elif action == "released":
            self.keystate &= (0xFF & ~keymap[key])

        # coasting is allowed but any keys pressed sets a new goal
        if self.keystate:
            self.target = np.array([0.0,0.0])
            if self.keystate & keymap[Qt.Key.Key_Up]:
                self.target += np.array([100.0,100.0])
            if self.keystate & keymap[Qt.Key.Key_Down]:
                self.target += np.array([-100.0,-100.0])

            # Motor drive is correct but left/right are swapped
            # at the motor driver - swap them here
            if self.keystate & keymap[Qt.Key.Key_Left]:
                self.target += np.array([50.0,-50.0])
            if self.keystate & keymap[Qt.Key.Key_Right]:
                self.target += np.array([-50.0,50.0])

            # braking is immediate
            if self.keystate & keymap[Qt.Key.Key_Space]:
                self.target = self.speed = np.array([0.0,0.0])

            scale = np.max(np.abs(self.target))
            # handle additive overrange
            if scale > 100:
                self.target = self.target * 100.0 / scale

        else:
            self.target = self.speed

    def control_update(self):
        global throttle_prints
        now = time.perf_counter()
        delta_time = now - self.previous_time
        self.previous_time = now

        # Calculate the desired change in speed
        delta = self.target - self.speed
        # Calculate the change in speed allowed by the rate limit
        allowed_delta = np.clip(delta, -rate_limit * delta_time, rate_limit * delta_time)

        # Update speed by applying the allowed change
        self.speed += allowed_delta

        command = 'drive:' + ','.join(np.round(self.speed).astype(int).astype(str))
        if self.lastcommand != command:
            send_message(command)
        self.lastcommand = command


    def init_ui(self):
        self.setWindowTitle("RTSP Stream Viewer")
        self.setGeometry(100, 100, 800, 600)

        self.image_label = QLabel(self)
        self.image_label.resize(800, 600)

        central_widget = QWidget()
        layout = QVBoxLayout()
        layout.addWidget(self.image_label)
        central_widget.setLayout(layout)

        self.setCentralWidget(central_widget)

    def display_frame(self, qt_image):
        self.image_label.setPixmap(QPixmap.fromImage(qt_image))

    def closeEvent(self, event):
        self.video_thread.stop()
        event.accept()

if __name__ == "__main__":
    rtsp_url = "rtsp://tank:8554/front"  # Replace with your RTSP stream URL
    app = QApplication(sys.argv)
    window = CameraControlWindow(rtsp_url)
    window.show()
    sys.exit(app.exec_())
